"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[798],{3905:(e,n,t)=>{t.d(n,{Zo:()=>d,kt:()=>f});var r=t(7294);function a(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function o(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);n&&(r=r.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,r)}return t}function i(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?o(Object(t),!0).forEach((function(n){a(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):o(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function s(e,n){if(null==e)return{};var t,r,a=function(e,n){if(null==e)return{};var t,r,a={},o=Object.keys(e);for(r=0;r<o.length;r++)t=o[r],n.indexOf(t)>=0||(a[t]=e[t]);return a}(e,n);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(r=0;r<o.length;r++)t=o[r],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(a[t]=e[t])}return a}var u=r.createContext({}),l=function(e){var n=r.useContext(u),t=n;return e&&(t="function"==typeof e?e(n):i(i({},n),e)),t},d=function(e){var n=l(e.components);return r.createElement(u.Provider,{value:n},e.children)},c={inlineCode:"code",wrapper:function(e){var n=e.children;return r.createElement(r.Fragment,{},n)}},p=r.forwardRef((function(e,n){var t=e.components,a=e.mdxType,o=e.originalType,u=e.parentName,d=s(e,["components","mdxType","originalType","parentName"]),p=l(t),f=a,m=p["".concat(u,".").concat(f)]||p[f]||c[f]||o;return t?r.createElement(m,i(i({ref:n},d),{},{components:t})):r.createElement(m,i({ref:n},d))}));function f(e,n){var t=arguments,a=n&&n.mdxType;if("string"==typeof e||a){var o=t.length,i=new Array(o);i[0]=p;var s={};for(var u in n)hasOwnProperty.call(n,u)&&(s[u]=n[u]);s.originalType=e,s.mdxType="string"==typeof e?e:a,i[1]=s;for(var l=2;l<o;l++)i[l]=t[l];return r.createElement.apply(null,i)}return r.createElement.apply(null,t)}p.displayName="MDXCreateElement"},2442:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>u,contentTitle:()=>i,default:()=>c,frontMatter:()=>o,metadata:()=>s,toc:()=>l});var r=t(7462),a=(t(7294),t(3905));const o={sidebar_position:1},i="Intefaces",s={unversionedId:"For Developers/Interfaces",id:"For Developers/Interfaces",title:"Intefaces",description:"Please refer to GitHub.",source:"@site/docs/For Developers/Interfaces.md",sourceDirName:"For Developers",slug:"/For Developers/Interfaces",permalink:"/KeepERC20-docs/For Developers/Interfaces",draft:!1,tags:[],version:"current",sidebarPosition:1,frontMatter:{sidebar_position:1},sidebar:"tutorialSidebar",previous:{title:"For Developers",permalink:"/KeepERC20-docs/category/for-developers"},next:{title:"Deploy",permalink:"/KeepERC20-docs/For Developers/Deploy"}},u={},l=[{value:"<code>IKeepERC20.sol</code>",id:"ikeeperc20sol",level:2},{value:"<code>IKeepERC20Factory.sol</code>",id:"ikeeperc20factorysol",level:2},{value:"<code>IKeepERC20Upkeep.sol</code>",id:"ikeeperc20upkeepsol",level:2},{value:"<code>IWallet.sol</code>",id:"iwalletsol",level:2}],d={toc:l};function c(e){let{components:n,...t}=e;return(0,a.kt)("wrapper",(0,r.Z)({},d,t,{components:n,mdxType:"MDXLayout"}),(0,a.kt)("h1",{id:"intefaces"},"Intefaces"),(0,a.kt)("p",null,"Please refer to ",(0,a.kt)("a",{parentName:"p",href:"https://github.com/KeepERC20/KeepERC20-wrapper/tree/main/contracts/interfaces"},"GitHub"),"."),(0,a.kt)("hr",null),(0,a.kt)("h2",{id:"ikeeperc20sol"},(0,a.kt)("inlineCode",{parentName:"h2"},"IKeepERC20.sol")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-solidity"},"// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.17;\n\ninterface IKeepERC20 {\n    //============ Params ============//\n\n    enum TaskType {\n        Schedule,\n        Recovery,\n        Expire\n    }\n\n    struct Task {\n        TaskType taskType;\n        address sender;\n        address receiver;\n        uint256 amount;\n        bytes extraField;\n        bool active;\n    }\n\n    //============ Events ============//\n\n    event SetScheduleFeeRatio(uint256 prev, uint256 curr);\n    event SetRecoveryFeeRatio(uint256 prev, uint256 curr);\n    event SetFeeTo(address prev, address curr);\n\n    event Wrap(address indexed from, address indexed to, uint256 amount);\n    event Unwrap(address indexed from, address indexed to, uint256 amount);\n\n    event CreateWallet(address indexed account, address wallet);\n\n    event CancelTask(address indexed account, uint256 indexed tid);\n\n    event QueueScheduledTransfer(\n        uint256 indexed tid,\n        address from,\n        address to,\n        uint256 amount,\n        bytes extra,\n        uint256 interval\n    );\n    event ExecuteScheduledTransfer(uint256 indexed tid);\n\n    event QueueRecoverableTransfer(\n        uint256 indexed tid,\n        address from,\n        address to,\n        uint256 amount,\n        bytes extra,\n        uint256 interval\n    );\n    event ExecuteRecoverableTransfer(uint256 indexed tid);\n\n    event QueueExpirableApprove(\n        uint256 indexed tid,\n        address owner,\n        address spender,\n        uint256 amount,\n        uint256 interval\n    );\n    event ExecuteExpirableApprove(uint256 indexed tid);\n\n    //============ Initialize ============//\n\n    function token() external view returns (address);\n\n    function setScheduleFeeRatio(uint256 newScheduleFeeRatio_) external;\n\n    function setRecoveryFeeRatio(uint256 newRecoveryFeeRatio_) external;\n\n    function setFeeTo(address newFeeTo_) external;\n\n    //============ View Functions ============//\n\n    function tasks(uint256 tid) external view returns (Task memory);\n\n    function tasksOf(address account)\n        external\n        view\n        returns (uint256[] memory tids);\n\n    function activeTasksOf(address account)\n        external\n        view\n        returns (uint256[] memory tids);\n\n    function walletOf(address account) external view returns (address);\n\n    //============ Wrap & Unwrap ============//\n\n    function wrap(address to, uint256 amount) external returns (bool);\n\n    function unwrap(address to, uint256 amount) external returns (bool);\n\n    function wrapFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) external returns (bool);\n\n    function unwrapFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) external returns (bool);\n\n    //============ Wallet Functions ============//\n\n    function createWallet() external returns (address);\n\n    function revokeWallet() external returns (address);\n\n    function callWallet(\n        address target,\n        uint256 value,\n        string memory signature,\n        bytes memory data\n    ) external returns (bool success, bytes memory returnData);\n\n    //============ KeepERC20 Functions ============//\n\n    function cancel(uint256 tid) external returns (bool);\n\n    //============ KeepERC20 Functions: Scheduled Transfer ============//\n\n    function queueScheduledTransfer(\n        address to,\n        uint256 amount,\n        uint256 interval\n    ) external returns (bool);\n\n    function queueScheduledTransferWithExtra(\n        address to,\n        uint256 amount,\n        bytes memory extra,\n        uint256 interval\n    ) external returns (bool);\n\n    function queueScheduledTransferFrom(\n        address from,\n        address to,\n        uint256 amount,\n        uint256 interval\n    ) external returns (bool);\n\n    function queueScheduledTransferFromWithExtra(\n        address from,\n        address to,\n        uint256 amount,\n        bytes memory extra,\n        uint256 interval\n    ) external returns (bool);\n\n    function executeScheduledTransfer(uint256 tid)\n        external\n        returns (bytes memory returndata);\n\n    //============ KeepERC20 Functions: Recoverable Transfer ============//\n\n    function queueRecoverableTransfer(\n        address to,\n        uint256 amount,\n        uint256 interval\n    ) external returns (bool);\n\n    function queueRecoverableTransferWithExtra(\n        address to,\n        uint256 amount,\n        bytes memory extra,\n        uint256 interval\n    ) external returns (bool);\n\n    function queueRecoverableTransferFrom(\n        address from,\n        address to,\n        uint256 amount,\n        uint256 interval\n    ) external returns (bool);\n\n    function queueRecoverableTransferFromWithExtra(\n        address from,\n        address to,\n        uint256 amount,\n        bytes memory extra,\n        uint256 interval\n    ) external returns (bool);\n\n    function executeRecoverableTransfer(uint256 tid)\n        external\n        returns (bytes memory returndata);\n\n    //============ KeepERC20 Functions: Expirable Approve ============//\n\n    function queueExpirableApprove(\n        address spender,\n        uint256 amount,\n        uint256 interval\n    ) external returns (uint256 tid);\n\n    function executeExpirableApprove(uint256 tid)\n        external\n        returns (bytes memory returndata);\n}\n")),(0,a.kt)("h2",{id:"ikeeperc20factorysol"},(0,a.kt)("inlineCode",{parentName:"h2"},"IKeepERC20Factory.sol")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-solidity"},"// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.17;\n\ninterface IKeepERC20Factory {\n    //============ Events ============//\n\n    event SetScheduleFeeRatio(uint256 prev, uint256 curr);\n    event SetRecoveryFeeRatio(uint256 prev, uint256 curr);\n    event SetFeeTo(address prev, address curr);\n\n    event NewKeepERC20(\n        address originalToken,\n        uint256 scheduleFeeRatio,\n        uint256 recoverFeeRatio,\n        address feeTo\n    );\n\n    //============ Initialize ============//\n\n    function setScheduleFeeRatio(uint256 newScheduleFeeRatio_) external;\n\n    function setRecoveryFeeRatio(uint256 newRecoveryFeeRatio_) external;\n\n    function setFeeTo(address newFeeTo_) external;\n\n    //============ View Functions ============//\n\n    function keepOf(address token) external view returns (address);\n\n    function keeps(uint256 index) external view returns (address);\n\n    //============ Factory Functions ============//\n\n    function allKeepsLength() external view returns (uint256);\n\n    function createKeep(address token) external returns (address keepToken);\n}\n")),(0,a.kt)("h2",{id:"ikeeperc20upkeepsol"},(0,a.kt)("inlineCode",{parentName:"h2"},"IKeepERC20Upkeep.sol")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-solidity"},"// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.17;\n\ninterface IKeepERC20Factory {\n    //============ Automation ============//\n\n    function pagination(uint256 lowerBound, uint256 upperBound)\n        external\n        pure\n        returns (bytes memory);\n\n    function checkUpkeep(bytes calldata checkData)\n        external\n        view\n        returns (bool upkeepNeeded, bytes memory performData);\n\n    function performUpkeep(bytes calldata performData) external;\n}\n")),(0,a.kt)("h2",{id:"iwalletsol"},(0,a.kt)("inlineCode",{parentName:"h2"},"IWallet.sol")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-solidity"},'// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.17;\n\nimport "@openzeppelin/contracts/access/Ownable.sol";\n\ninterface IWallet {\n    event WalletCall(\n        address indexed owner,\n        address target,\n        uint256 value,\n        string signature,\n        bytes data\n    );\n    event RevokeWallet(address indexed account, address wallet);\n\n    function call(\n        address target,\n        uint256 value,\n        string memory signature,\n        bytes memory data\n    ) external returns (bool success, bytes memory returnData);\n\n    function revoke() external;\n}\n')))}c.isMDXComponent=!0}}]);