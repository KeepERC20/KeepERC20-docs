"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[488],{3905:(e,t,r)=>{r.d(t,{Zo:()=>p,kt:()=>f});var n=r(7294);function o(e,t,r){return t in e?Object.defineProperty(e,t,{value:r,enumerable:!0,configurable:!0,writable:!0}):e[t]=r,e}function a(e,t){var r=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),r.push.apply(r,n)}return r}function i(e){for(var t=1;t<arguments.length;t++){var r=null!=arguments[t]?arguments[t]:{};t%2?a(Object(r),!0).forEach((function(t){o(e,t,r[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(r)):a(Object(r)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(r,t))}))}return e}function s(e,t){if(null==e)return{};var r,n,o=function(e,t){if(null==e)return{};var r,n,o={},a=Object.keys(e);for(n=0;n<a.length;n++)r=a[n],t.indexOf(r)>=0||(o[r]=e[r]);return o}(e,t);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(n=0;n<a.length;n++)r=a[n],t.indexOf(r)>=0||Object.prototype.propertyIsEnumerable.call(e,r)&&(o[r]=e[r])}return o}var c=n.createContext({}),l=function(e){var t=n.useContext(c),r=t;return e&&(r="function"==typeof e?e(t):i(i({},t),e)),r},p=function(e){var t=l(e.components);return n.createElement(c.Provider,{value:t},e.children)},u={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},d=n.forwardRef((function(e,t){var r=e.components,o=e.mdxType,a=e.originalType,c=e.parentName,p=s(e,["components","mdxType","originalType","parentName"]),d=l(r),f=o,v=d["".concat(c,".").concat(f)]||d[f]||u[f]||a;return r?n.createElement(v,i(i({ref:t},p),{},{components:r})):n.createElement(v,i({ref:t},p))}));function f(e,t){var r=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var a=r.length,i=new Array(a);i[0]=d;var s={};for(var c in t)hasOwnProperty.call(t,c)&&(s[c]=t[c]);s.originalType=e,s.mdxType="string"==typeof e?e:o,i[1]=s;for(var l=2;l<a;l++)i[l]=r[l];return n.createElement.apply(null,i)}return n.createElement.apply(null,r)}d.displayName="MDXCreateElement"},5418:(e,t,r)=>{r.r(t),r.d(t,{assets:()=>c,contentTitle:()=>i,default:()=>u,frontMatter:()=>a,metadata:()=>s,toc:()=>l});var n=r(7462),o=(r(7294),r(3905));const a={sidebar_position:3},i="Overview",s={unversionedId:"Overview",id:"Overview",title:"Overview",description:"- When a user sends ERC20 tokens to KeeperC, they are wrapped into KeeperC tokens, allowing the user to take advantage of various features such as scheduled transfers, lost money recovery, expirable approval, and fraud detection through smart contracts and Chainlink Automation.",source:"@site/docs/Overview.md",sourceDirName:".",slug:"/Overview",permalink:"/KeepERC20-docs/Overview",draft:!1,tags:[],version:"current",sidebarPosition:3,frontMatter:{sidebar_position:3},sidebar:"tutorialSidebar",previous:{title:"KeeperC",permalink:"/KeepERC20-docs/Introduction/KeepERC20"},next:{title:"Functions",permalink:"/KeepERC20-docs/category/functions"}},c={},l=[],p={toc:l};function u(e){let{components:t,...a}=e;return(0,o.kt)("wrapper",(0,n.Z)({},p,a,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("h1",{id:"overview"},"Overview"),(0,o.kt)("p",null,(0,o.kt)("img",{src:r(2563).Z,width:"3808",height:"1572"})),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"When a user sends ERC20 tokens to KeeperC, they are wrapped into KeeperC tokens, allowing the user to take advantage of various features such as scheduled transfers, lost money recovery, expirable approval, and fraud detection through smart contracts and Chainlink Automation."),(0,o.kt)("li",{parentName:"ul"},"When the recipient receives the tokens, they are automatically unwrapped back into the original ERC20 tokens, making it easy to use the tokens with other dApps.")),(0,o.kt)("p",null,"However, in some cases, simple token wrapping may not be enough to perform certain tasks, such as ownership-related function calls."),(0,o.kt)("p",null,"To address these cases, KeeperC creates a safe contract wallet internally and provides these functions seamlessly to ensure the security and convenience of users' tokens."),(0,o.kt)("p",null,"With KeeperC, you can enjoy a secure and convenient way to manage your tokens while participating in the decentralized blockchain ecosystem."))}u.isMDXComponent=!0},2563:(e,t,r)=>{r.d(t,{Z:()=>n});const n=r.p+"assets/images/fig4-1fd34fdae52d1881539aa71759842fbb.png"}}]);